%%%-------------------------------------------------------------------
%%% @author 'SongCF'
%%% @copyright (C) 2016, <JH>
%%% @doc
%%%
%%% @end
%%% Created : 12. 六月 2016 11:26
%%%-------------------------------------------------------------------
-module(proto_tool).

-description("proto_tool").
-copyright({jh, 'www.jh.com'}).
-author({'SongCF', 'songcf_faith@foxmail.com'}).
-vsn(1).

%%%================================EXPORT================================
-export([run/2]).

-define(ENABLE_LOG, false). %% true / false

log(false,_Arg)->
    ok;
log(true,Arg)->
    io:format(Arg).
log(false, _Arg1, _Arg2)->
    ok;
log(true, Arg1, Arg2)->
    io:format(Arg1, Arg2).


run(SrcPath, DstPath)->
    Src = SrcPath ++ "payload.proto",
    log(true, "gen csv,enum file begin...~n"),

    {ok, Fd} = file:open(Src, [raw, binary]),
    {Csv, Enum, Cmd2Name, Name2Cmd} = parse_line(Fd, [], {"", "", "", ""}, <<>>),

    %% 导出 cmd -> msg , msg -> cmd 的匹配代码
    CmdNameFile = DstPath ++ "packet_x.erl",
    CmdNameData = lists:append([
        "%% this document is generated by proto_tool;\n",
        "-module(packet_x).\n",
        "-compile([export_all]).\n\n",
        Cmd2Name,
        "cmd_to_name(Cmd) -> lager:info(\"bad_pkt_cmd Cmd = ~p\", [Cmd]), throw(bad_pkt_cmd).\n\n",
        Name2Cmd,
        "name_to_cmd(Name) -> lager:info(\"bad_pkt_name Name = ~p\", [Name]), throw(bad_pkt_name).\n\n"
        ]),
    ok = file:write_file(CmdNameFile, list_to_binary(CmdNameData)),

    %% 将 payload.proto 转换为 csv
    CsvFile = SrcPath ++ "payload.csv",
    ok = file:write_file(CsvFile, list_to_binary(Csv)),

    %% 导出 payload.proto 中的enum
    EnumFile = SrcPath ++ "BaseDefine.proto",
    EnumData = lists:append([
        "// file generated by proto_tool;\n",
        "package VCity.Proto;\n",
        "\nenum E_MESSAGE_TYPE\n",
        "{\n",
        "    option allow_alias = true;\n",
        Enum,
        "}\n"]),
    ok = file:write_file(EnumFile, list_to_binary(EnumData)),

    log(true, "success... ~n"),
    ok.

parse_line(Fd, L, {AccCsv, AccEnum, AccCmd2Name, AccName2Cmd}=Acc, LastLine)->
    log(?ENABLE_LOG, "csv_line...~n"),
    case file:read_line(Fd) of
        eof ->
            Acc;
        {ok, Line} ->
            case binary:split(Line, [<<"// cmd:">>, <<"\n">>], [global]) of
                [<<>>, CmdBin, <<>>] ->
                    Cmd = binary_to_list(CmdBin),
                    log(?ENABLE_LOG, "Cmd = ~p~n", [Cmd]),
                    case lists:member(Cmd, L) of
                        true -> throw("duplicate_cmd_number");
                        _ -> ok
                    end,

                    Describe = case binary:split(LastLine, [<<"// ">>, <<"\n">>], [global]) of
                                   [<<>>, Desc, <<>>] -> binary_to_list(Desc);%%io_lib:format("~ts", [Desc]);
                                   _ -> ""
                               end,
                    log(?ENABLE_LOG, "Describe = ~p~n", [Describe]),

                    {ok, NextLine} = file:read_line(Fd),
                    Msg = case binary:split(NextLine, <<" ">>, [global]) of
                              [<<"message">>, M, <<"{\n">>] -> binary_to_list(M);
                              _ -> throw("message_match_error")
                          end,
                    log(?ENABLE_LOG, "Msg = ~p~n", [Msg]),
                    log(?ENABLE_LOG, "===========================~n"),

                    L2 = [Cmd|L],
                    NewCsv = lists:append([AccCsv, Cmd, ",", Msg, ",", Describe, ",\n"]),
                    NewEnum = lists:append([AccEnum, "    ", string:to_upper(Msg), " = ", Cmd, "; //", Describe, "\n"]),
                    NewCmd2Name = lists:append([AccCmd2Name, "cmd_to_name(", Cmd, ") -> ", Msg, ";\n"]),
                    NewName2Cmd = lists:append([AccName2Cmd, "name_to_cmd(", Msg, ") -> ", Cmd, ";\n"]),
                    parse_line(Fd, L2, {NewCsv,NewEnum,NewCmd2Name,NewName2Cmd}, NextLine);
                _ ->
                    parse_line(Fd, L, Acc, Line)
            end;
        {error, Reason}->
            throw("read line error, reason = " ++ Reason)
    end.
